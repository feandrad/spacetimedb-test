// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

// This was generated using spacetimedb cli version 1.11.1 (commit bbfa851b45db7096aa2a69d7dbad84f52983559f).

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB.Types
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        internal RemoteReducers(DbConnection conn, SetReducerFlags flags) : base(conn) => SetCallReducerFlags = flags;
        internal readonly SetReducerFlags SetCallReducerFlags;
        internal event Action<ReducerEventContext, Exception>? InternalOnUnhandledReducerError;
    }

    public sealed partial class RemoteProcedures : RemoteBase
    {
        internal RemoteProcedures(DbConnection conn) : base(conn) { }
    }

    public sealed partial class RemoteTables : RemoteTablesBase
    {
        public RemoteTables(DbConnection conn)
        {
            AddTable(CombatEvent = new(conn));
            AddTable(Enemy = new(conn));
            AddTable(InteractableObject = new(conn));
            AddTable(InventoryItem = new(conn));
            AddTable(MapInstance = new(conn));
            AddTable(MapTemplate = new(conn));
            AddTable(MapTransition = new(conn));
            AddTable(Player = new(conn));
            AddTable(PlayerEquipment = new(conn));
            AddTable(Projectile = new(conn));
            AddTable(ResourceIdMapping = new(conn));
            AddTable(ResourceRegistry = new(conn));
            AddTable(WorldMutation = new(conn));
        }
    }

    public sealed partial class SetReducerFlags { }

    public interface IRemoteDbContext : IDbContext<RemoteTables, RemoteReducers, SetReducerFlags, SubscriptionBuilder, RemoteProcedures>
    {
        public event Action<ReducerEventContext, Exception>? OnUnhandledReducerError;
    }

    public sealed class EventContext : IEventContext, IRemoteDbContext
    {
        private readonly DbConnection conn;

        /// <summary>
        /// The event that caused this callback to run.
        /// </summary>
        public readonly Event<Reducer> Event;

        /// <summary>
        /// Access to tables in the client cache, which stores a read-only replica of the remote database state.
        ///
        /// The returned <c>DbView</c> will have a method to access each table defined by the module.
        /// </summary>
        public RemoteTables Db => conn.Db;
        /// <summary>
        /// Access to reducers defined by the module.
        ///
        /// The returned <c>RemoteReducers</c> will have a method to invoke each reducer defined by the module,
        /// plus methods for adding and removing callbacks on each of those reducers.
        /// </summary>
        public RemoteReducers Reducers => conn.Reducers;
        /// <summary>
        /// Access to setters for per-reducer flags.
        ///
        /// The returned <c>SetReducerFlags</c> will have a method to invoke,
        /// for each reducer defined by the module,
        /// which call-flags for the reducer can be set.
        /// </summary>
        public SetReducerFlags SetReducerFlags => conn.SetReducerFlags;
        /// <summary>
        /// Access to procedures defined by the module.
        ///
        /// The returned <c>RemoteProcedures</c> will have a method to invoke each procedure defined by the module,
        /// with a callback for when the procedure completes and returns a value.
        /// </summary>
        public RemoteProcedures Procedures => conn.Procedures;
        /// <summary>
        /// Returns <c>true</c> if the connection is active, i.e. has not yet disconnected.
        /// </summary>
        public bool IsActive => conn.IsActive;
        /// <summary>
        /// Close the connection.
        ///
        /// Throws an error if the connection is already closed.
        /// </summary>
        public void Disconnect()
        {
            conn.Disconnect();
        }
        /// <summary>
        /// Start building a subscription.
        /// </summary>
        /// <returns>A builder-pattern constructor for subscribing to queries,
        /// causing matching rows to be replicated into the client cache.</returns>
        public SubscriptionBuilder SubscriptionBuilder() => conn.SubscriptionBuilder();
        /// <summary>
        /// Get the <c>Identity</c> of this connection.
        ///
        /// This method returns null if the connection was constructed anonymously
        /// and we have not yet received our newly-generated <c>Identity</c> from the host.
        /// </summary>
        public Identity? Identity => conn.Identity;
        /// <summary>
        /// Get this connection's <c>ConnectionId</c>.
        /// </summary>
        public ConnectionId ConnectionId => conn.ConnectionId;
        /// <summary>
        /// Register a callback to be called when a reducer with no handler returns an error.
        /// </summary>
        public event Action<ReducerEventContext, Exception>? OnUnhandledReducerError
        {
            add => Reducers.InternalOnUnhandledReducerError += value;
            remove => Reducers.InternalOnUnhandledReducerError -= value;
        }

        internal EventContext(DbConnection conn, Event<Reducer> Event)
        {
            this.conn = conn;
            this.Event = Event;
        }
    }

    public sealed class ReducerEventContext : IReducerEventContext, IRemoteDbContext
    {
        private readonly DbConnection conn;
        /// <summary>
        /// The reducer event that caused this callback to run.
        /// </summary>
        public readonly ReducerEvent<Reducer> Event;

        /// <summary>
        /// Access to tables in the client cache, which stores a read-only replica of the remote database state.
        ///
        /// The returned <c>DbView</c> will have a method to access each table defined by the module.
        /// </summary>
        public RemoteTables Db => conn.Db;
        /// <summary>
        /// Access to reducers defined by the module.
        ///
        /// The returned <c>RemoteReducers</c> will have a method to invoke each reducer defined by the module,
        /// plus methods for adding and removing callbacks on each of those reducers.
        /// </summary>
        public RemoteReducers Reducers => conn.Reducers;
        /// <summary>
        /// Access to setters for per-reducer flags.
        ///
        /// The returned <c>SetReducerFlags</c> will have a method to invoke,
        /// for each reducer defined by the module,
        /// which call-flags for the reducer can be set.
        /// </summary>
        public SetReducerFlags SetReducerFlags => conn.SetReducerFlags;
        /// <summary>
        /// Access to procedures defined by the module.
        ///
        /// The returned <c>RemoteProcedures</c> will have a method to invoke each procedure defined by the module,
        /// with a callback for when the procedure completes and returns a value.
        /// </summary>
        public RemoteProcedures Procedures => conn.Procedures;
        /// <summary>
        /// Returns <c>true</c> if the connection is active, i.e. has not yet disconnected.
        /// </summary>
        public bool IsActive => conn.IsActive;
        /// <summary>
        /// Close the connection.
        ///
        /// Throws an error if the connection is already closed.
        /// </summary>
        public void Disconnect()
        {
            conn.Disconnect();
        }
        /// <summary>
        /// Start building a subscription.
        /// </summary>
        /// <returns>A builder-pattern constructor for subscribing to queries,
        /// causing matching rows to be replicated into the client cache.</returns>
        public SubscriptionBuilder SubscriptionBuilder() => conn.SubscriptionBuilder();
        /// <summary>
        /// Get the <c>Identity</c> of this connection.
        ///
        /// This method returns null if the connection was constructed anonymously
        /// and we have not yet received our newly-generated <c>Identity</c> from the host.
        /// </summary>
        public Identity? Identity => conn.Identity;
        /// <summary>
        /// Get this connection's <c>ConnectionId</c>.
        /// </summary>
        public ConnectionId ConnectionId => conn.ConnectionId;
        /// <summary>
        /// Register a callback to be called when a reducer with no handler returns an error.
        /// </summary>
        public event Action<ReducerEventContext, Exception>? OnUnhandledReducerError
        {
            add => Reducers.InternalOnUnhandledReducerError += value;
            remove => Reducers.InternalOnUnhandledReducerError -= value;
        }

        internal ReducerEventContext(DbConnection conn, ReducerEvent<Reducer> reducerEvent)
        {
            this.conn = conn;
            Event = reducerEvent;
        }
    }

    public sealed class ErrorContext : IErrorContext, IRemoteDbContext
    {
        private readonly DbConnection conn;
        /// <summary>
        /// The <c>Exception</c> that caused this error callback to be run.
        /// </summary>
        public readonly Exception Event;
        Exception IErrorContext.Event
        {
            get
            {
                return Event;
            }
        }

        /// <summary>
        /// Access to tables in the client cache, which stores a read-only replica of the remote database state.
        ///
        /// The returned <c>DbView</c> will have a method to access each table defined by the module.
        /// </summary>
        public RemoteTables Db => conn.Db;
        /// <summary>
        /// Access to reducers defined by the module.
        ///
        /// The returned <c>RemoteReducers</c> will have a method to invoke each reducer defined by the module,
        /// plus methods for adding and removing callbacks on each of those reducers.
        /// </summary>
        public RemoteReducers Reducers => conn.Reducers;
        /// <summary>
        /// Access to setters for per-reducer flags.
        ///
        /// The returned <c>SetReducerFlags</c> will have a method to invoke,
        /// for each reducer defined by the module,
        /// which call-flags for the reducer can be set.
        /// </summary>
        public SetReducerFlags SetReducerFlags => conn.SetReducerFlags;
        /// <summary>
        /// Access to procedures defined by the module.
        ///
        /// The returned <c>RemoteProcedures</c> will have a method to invoke each procedure defined by the module,
        /// with a callback for when the procedure completes and returns a value.
        /// </summary>
        public RemoteProcedures Procedures => conn.Procedures;
        /// <summary>
        /// Returns <c>true</c> if the connection is active, i.e. has not yet disconnected.
        /// </summary>
        public bool IsActive => conn.IsActive;
        /// <summary>
        /// Close the connection.
        ///
        /// Throws an error if the connection is already closed.
        /// </summary>
        public void Disconnect()
        {
            conn.Disconnect();
        }
        /// <summary>
        /// Start building a subscription.
        /// </summary>
        /// <returns>A builder-pattern constructor for subscribing to queries,
        /// causing matching rows to be replicated into the client cache.</returns>
        public SubscriptionBuilder SubscriptionBuilder() => conn.SubscriptionBuilder();
        /// <summary>
        /// Get the <c>Identity</c> of this connection.
        ///
        /// This method returns null if the connection was constructed anonymously
        /// and we have not yet received our newly-generated <c>Identity</c> from the host.
        /// </summary>
        public Identity? Identity => conn.Identity;
        /// <summary>
        /// Get this connection's <c>ConnectionId</c>.
        /// </summary>
        public ConnectionId ConnectionId => conn.ConnectionId;
        /// <summary>
        /// Register a callback to be called when a reducer with no handler returns an error.
        /// </summary>
        public event Action<ReducerEventContext, Exception>? OnUnhandledReducerError
        {
            add => Reducers.InternalOnUnhandledReducerError += value;
            remove => Reducers.InternalOnUnhandledReducerError -= value;
        }

        internal ErrorContext(DbConnection conn, Exception error)
        {
            this.conn = conn;
            Event = error;
        }
    }

    public sealed class SubscriptionEventContext : ISubscriptionEventContext, IRemoteDbContext
    {
        private readonly DbConnection conn;

        /// <summary>
        /// Access to tables in the client cache, which stores a read-only replica of the remote database state.
        ///
        /// The returned <c>DbView</c> will have a method to access each table defined by the module.
        /// </summary>
        public RemoteTables Db => conn.Db;
        /// <summary>
        /// Access to reducers defined by the module.
        ///
        /// The returned <c>RemoteReducers</c> will have a method to invoke each reducer defined by the module,
        /// plus methods for adding and removing callbacks on each of those reducers.
        /// </summary>
        public RemoteReducers Reducers => conn.Reducers;
        /// <summary>
        /// Access to setters for per-reducer flags.
        ///
        /// The returned <c>SetReducerFlags</c> will have a method to invoke,
        /// for each reducer defined by the module,
        /// which call-flags for the reducer can be set.
        /// </summary>
        public SetReducerFlags SetReducerFlags => conn.SetReducerFlags;
        /// <summary>
        /// Access to procedures defined by the module.
        ///
        /// The returned <c>RemoteProcedures</c> will have a method to invoke each procedure defined by the module,
        /// with a callback for when the procedure completes and returns a value.
        /// </summary>
        public RemoteProcedures Procedures => conn.Procedures;
        /// <summary>
        /// Returns <c>true</c> if the connection is active, i.e. has not yet disconnected.
        /// </summary>
        public bool IsActive => conn.IsActive;
        /// <summary>
        /// Close the connection.
        ///
        /// Throws an error if the connection is already closed.
        /// </summary>
        public void Disconnect()
        {
            conn.Disconnect();
        }
        /// <summary>
        /// Start building a subscription.
        /// </summary>
        /// <returns>A builder-pattern constructor for subscribing to queries,
        /// causing matching rows to be replicated into the client cache.</returns>
        public SubscriptionBuilder SubscriptionBuilder() => conn.SubscriptionBuilder();
        /// <summary>
        /// Get the <c>Identity</c> of this connection.
        ///
        /// This method returns null if the connection was constructed anonymously
        /// and we have not yet received our newly-generated <c>Identity</c> from the host.
        /// </summary>
        public Identity? Identity => conn.Identity;
        /// <summary>
        /// Get this connection's <c>ConnectionId</c>.
        /// </summary>
        public ConnectionId ConnectionId => conn.ConnectionId;
        /// <summary>
        /// Register a callback to be called when a reducer with no handler returns an error.
        /// </summary>
        public event Action<ReducerEventContext, Exception>? OnUnhandledReducerError
        {
            add => Reducers.InternalOnUnhandledReducerError += value;
            remove => Reducers.InternalOnUnhandledReducerError -= value;
        }

        internal SubscriptionEventContext(DbConnection conn)
        {
            this.conn = conn;
        }
    }

    public sealed class ProcedureEventContext : IProcedureEventContext, IRemoteDbContext
    {
        private readonly DbConnection conn;
        /// <summary>
        /// The procedure event that caused this callback to run.
        /// </summary>
        public readonly ProcedureEvent Event;

        /// <summary>
        /// Access to tables in the client cache, which stores a read-only replica of the remote database state.
        ///
        /// The returned <c>DbView</c> will have a method to access each table defined by the module.
        /// </summary>
        public RemoteTables Db => conn.Db;
        /// <summary>
        /// Access to reducers defined by the module.
        ///
        /// The returned <c>RemoteReducers</c> will have a method to invoke each reducer defined by the module,
        /// plus methods for adding and removing callbacks on each of those reducers.
        /// </summary>
        public RemoteReducers Reducers => conn.Reducers;
        /// <summary>
        /// Access to setters for per-reducer flags.
        ///
        /// The returned <c>SetReducerFlags</c> will have a method to invoke,
        /// for each reducer defined by the module,
        /// which call-flags for the reducer can be set.
        /// </summary>
        public SetReducerFlags SetReducerFlags => conn.SetReducerFlags;
        /// <summary>
        /// Access to procedures defined by the module.
        ///
        /// The returned <c>RemoteProcedures</c> will have a method to invoke each procedure defined by the module,
        /// with a callback for when the procedure completes and returns a value.
        /// </summary>
        public RemoteProcedures Procedures => conn.Procedures;
        /// <summary>
        /// Returns <c>true</c> if the connection is active, i.e. has not yet disconnected.
        /// </summary>
        public bool IsActive => conn.IsActive;
        /// <summary>
        /// Close the connection.
        ///
        /// Throws an error if the connection is already closed.
        /// </summary>
        public void Disconnect()
        {
            conn.Disconnect();
        }
        /// <summary>
        /// Start building a subscription.
        /// </summary>
        /// <returns>A builder-pattern constructor for subscribing to queries,
        /// causing matching rows to be replicated into the client cache.</returns>
        public SubscriptionBuilder SubscriptionBuilder() => conn.SubscriptionBuilder();
        /// <summary>
        /// Get the <c>Identity</c> of this connection.
        ///
        /// This method returns null if the connection was constructed anonymously
        /// and we have not yet received our newly-generated <c>Identity</c> from the host.
        /// </summary>
        public Identity? Identity => conn.Identity;
        /// <summary>
        /// Get this connection's <c>ConnectionId</c>.
        /// </summary>
        public ConnectionId ConnectionId => conn.ConnectionId;
        /// <summary>
        /// Register a callback to be called when a reducer with no handler returns an error.
        /// </summary>
        public event Action<ReducerEventContext, Exception>? OnUnhandledReducerError
        {
            add => Reducers.InternalOnUnhandledReducerError += value;
            remove => Reducers.InternalOnUnhandledReducerError -= value;
        }

        internal ProcedureEventContext(DbConnection conn, ProcedureEvent Event)
        {
            this.conn = conn;
            this.Event = Event;
        }
    }

    /// <summary>
    /// Builder-pattern constructor for subscription queries.
    /// </summary>
    public sealed class SubscriptionBuilder
    {
        private readonly IDbConnection conn;

        private event Action<SubscriptionEventContext>? Applied;
        private event Action<ErrorContext, Exception>? Error;

        /// <summary>
        /// Private API, use <c>conn.SubscriptionBuilder()</c> instead.
        /// </summary>
        public SubscriptionBuilder(IDbConnection conn)
        {
            this.conn = conn;
        }

        /// <summary>
        /// Register a callback to run when the subscription is applied.
        /// </summary>
        public SubscriptionBuilder OnApplied(
            Action<SubscriptionEventContext> callback
        )
        {
            Applied += callback;
            return this;
        }

        /// <summary>
        /// Register a callback to run when the subscription fails.
        ///
        /// Note that this callback may run either when attempting to apply the subscription,
        /// in which case <c>Self::on_applied</c> will never run,
        /// or later during the subscription's lifetime if the module's interface changes,
        /// in which case <c>Self::on_applied</c> may have already run.
        /// </summary>
        public SubscriptionBuilder OnError(
            Action<ErrorContext, Exception> callback
        )
        {
            Error += callback;
            return this;
        }

        /// <summary>
        /// Subscribe to the following SQL queries.
        ///
        /// This method returns immediately, with the data not yet added to the DbConnection.
        /// The provided callbacks will be invoked once the data is returned from the remote server.
        /// Data from all the provided queries will be returned at the same time.
        ///
        /// See the SpacetimeDB SQL docs for more information on SQL syntax:
        /// <a href="https://spacetimedb.com/docs/sql">https://spacetimedb.com/docs/sql</a>
        /// </summary>
        public SubscriptionHandle Subscribe(
            string[] querySqls
        ) => new(conn, Applied, Error, querySqls);

        /// <summary>
        /// Subscribe to all rows from all tables.
        ///
        /// This method is intended as a convenience
        /// for applications where client-side memory use and network bandwidth are not concerns.
        /// Applications where these resources are a constraint
        /// should register more precise queries via <c>Self.Subscribe</c>
        /// in order to replicate only the subset of data which the client needs to function.
        ///
        /// This method should not be combined with <c>Self.Subscribe</c> on the same <c>DbConnection</c>.
        /// A connection may either <c>Self.Subscribe</c> to particular queries,
        /// or <c>Self.SubscribeToAllTables</c>, but not both.
        /// Attempting to call <c>Self.Subscribe</c>
        /// on a <c>DbConnection</c> that has previously used <c>Self.SubscribeToAllTables</c>,
        /// or vice versa, may misbehave in any number of ways,
        /// including dropping subscriptions, corrupting the client cache, or panicking.
        /// </summary>
        public void SubscribeToAllTables()
        {
            // Make sure we use the legacy handle constructor here, even though there's only 1 query.
            // We drop the error handler, since it can't be called for legacy subscriptions.
            new SubscriptionHandle(
                conn,
                Applied,
                new string[] { "SELECT * FROM *" }
            );
        }
    }

    public sealed class SubscriptionHandle : SubscriptionHandleBase<SubscriptionEventContext, ErrorContext>
    {
        /// <summary>
        /// Internal API. Construct <c>SubscriptionHandle</c>s using <c>conn.SubscriptionBuilder</c>.
        /// </summary>
        public SubscriptionHandle(IDbConnection conn, Action<SubscriptionEventContext>? onApplied, string[] querySqls) : base(conn, onApplied, querySqls)
        { }

        /// <summary>
        /// Internal API. Construct <c>SubscriptionHandle</c>s using <c>conn.SubscriptionBuilder</c>.
        /// </summary>
        public SubscriptionHandle(
            IDbConnection conn,
            Action<SubscriptionEventContext>? onApplied,
            Action<ErrorContext, Exception>? onError,
            string[] querySqls
        ) : base(conn, onApplied, onError, querySqls)
        { }
    }

    public abstract partial class Reducer
    {
        private Reducer() { }
    }

    public abstract partial class Procedure
    {
        private Procedure() { }
    }

    public sealed class DbConnection : DbConnectionBase<DbConnection, RemoteTables, Reducer>
    {
        public override RemoteTables Db { get; }
        public readonly RemoteReducers Reducers;
        public readonly SetReducerFlags SetReducerFlags = new();
        public readonly RemoteProcedures Procedures;

        public DbConnection()
        {
            Db = new(this);
            Reducers = new(this, SetReducerFlags);
            Procedures = new(this);
        }

        protected override Reducer ToReducer(TransactionUpdate update)
        {
            var encodedArgs = update.ReducerCall.Args;
            return update.ReducerCall.ReducerName switch
            {
                "add_item_to_inventory" => BSATNHelpers.Decode<Reducer.AddItemToInventory>(encodedArgs),
                "apply_damage_to_player" => BSATNHelpers.Decode<Reducer.ApplyDamageToPlayer>(encodedArgs),
                "create_interactable_object" => BSATNHelpers.Decode<Reducer.CreateInteractableObject>(encodedArgs),
                "create_projectile" => BSATNHelpers.Decode<Reducer.CreateProjectile>(encodedArgs),
                "enemy_attack_player" => BSATNHelpers.Decode<Reducer.EnemyAttackPlayer>(encodedArgs),
                "enemy_transition_map" => BSATNHelpers.Decode<Reducer.EnemyTransitionMap>(encodedArgs),
                "equip_item" => BSATNHelpers.Decode<Reducer.EquipItem>(encodedArgs),
                "execute_attack" => BSATNHelpers.Decode<Reducer.ExecuteAttack>(encodedArgs),
                "execute_contextual_action" => BSATNHelpers.Decode<Reducer.ExecuteContextualAction>(encodedArgs),
                "force_player_position" => BSATNHelpers.Decode<Reducer.ForcePlayerPosition>(encodedArgs),
                "get_map_data" => BSATNHelpers.Decode<Reducer.GetMapData>(encodedArgs),
                "get_player_info" => BSATNHelpers.Decode<Reducer.GetPlayerInfo>(encodedArgs),
                "get_player_position" => BSATNHelpers.Decode<Reducer.GetPlayerPosition>(encodedArgs),
                "get_projectiles_in_map" => BSATNHelpers.Decode<Reducer.GetProjectilesInMap>(encodedArgs),
                "get_resource_by_id" => BSATNHelpers.Decode<Reducer.GetResourceById>(encodedArgs),
                "get_resource_by_key" => BSATNHelpers.Decode<Reducer.GetResourceByKey>(encodedArgs),
                "give_arrows_to_player" => BSATNHelpers.Decode<Reducer.GiveArrowsToPlayer>(encodedArgs),
                "heal_player" => BSATNHelpers.Decode<Reducer.HealPlayer>(encodedArgs),
                "health_check" => BSATNHelpers.Decode<Reducer.HealthCheck>(encodedArgs),
                "init_map_transitions" => BSATNHelpers.Decode<Reducer.InitMapTransitions>(encodedArgs),
                "list_resources_by_type" => BSATNHelpers.Decode<Reducer.ListResourcesByType>(encodedArgs),
                "on_connect" => BSATNHelpers.Decode<Reducer.OnConnect>(encodedArgs),
                "on_disconnect" => BSATNHelpers.Decode<Reducer.OnDisconnect>(encodedArgs),
                "pickup_item" => BSATNHelpers.Decode<Reducer.PickupItem>(encodedArgs),
                "process_hit" => BSATNHelpers.Decode<Reducer.ProcessHit>(encodedArgs),
                "register_player" => BSATNHelpers.Decode<Reducer.RegisterPlayer>(encodedArgs),
                "register_resource" => BSATNHelpers.Decode<Reducer.RegisterResource>(encodedArgs),
                "remove_enemy" => BSATNHelpers.Decode<Reducer.RemoveEnemy>(encodedArgs),
                "remove_resource" => BSATNHelpers.Decode<Reducer.RemoveResource>(encodedArgs),
                "replace_all_templates" => BSATNHelpers.Decode<Reducer.ReplaceAllTemplates>(encodedArgs),
                "revive_player" => BSATNHelpers.Decode<Reducer.RevivePlayer>(encodedArgs),
                "set_player_max_health" => BSATNHelpers.Decode<Reducer.SetPlayerMaxHealth>(encodedArgs),
                "spawn_enemy" => BSATNHelpers.Decode<Reducer.SpawnEnemy>(encodedArgs),
                "spawn_player_at_map" => BSATNHelpers.Decode<Reducer.SpawnPlayerAtMap>(encodedArgs),
                "spawn_test_enemy" => BSATNHelpers.Decode<Reducer.SpawnTestEnemy>(encodedArgs),
                "sync_resource_registry" => BSATNHelpers.Decode<Reducer.SyncResourceRegistry>(encodedArgs),
                "test_message" => BSATNHelpers.Decode<Reducer.TestMessage>(encodedArgs),
                "unequip_item" => BSATNHelpers.Decode<Reducer.UnequipItem>(encodedArgs),
                "update_enemy_ai" => BSATNHelpers.Decode<Reducer.UpdateEnemyAi>(encodedArgs),
                "update_player_position" => BSATNHelpers.Decode<Reducer.UpdatePlayerPosition>(encodedArgs),
                "update_projectiles" => BSATNHelpers.Decode<Reducer.UpdateProjectiles>(encodedArgs),
                "update_resource" => BSATNHelpers.Decode<Reducer.UpdateResource>(encodedArgs),
                "use_health_consumable" => BSATNHelpers.Decode<Reducer.UseHealthConsumable>(encodedArgs),
                "" => throw new SpacetimeDBEmptyReducerNameException("Reducer name is empty"),
                var reducer => throw new ArgumentOutOfRangeException("Reducer", $"Unknown reducer {reducer}")
            };
        }

        protected override IEventContext ToEventContext(Event<Reducer> Event) =>
        new EventContext(this, Event);

        protected override IReducerEventContext ToReducerEventContext(ReducerEvent<Reducer> reducerEvent) =>
        new ReducerEventContext(this, reducerEvent);

        protected override ISubscriptionEventContext MakeSubscriptionEventContext() =>
        new SubscriptionEventContext(this);

        protected override IErrorContext ToErrorContext(Exception exception) =>
        new ErrorContext(this, exception);

        protected override IProcedureEventContext ToProcedureEventContext(ProcedureEvent procedureEvent) =>
        new ProcedureEventContext(this, procedureEvent);

        protected override bool Dispatch(IReducerEventContext context, Reducer reducer)
        {
            var eventContext = (ReducerEventContext)context;
            return reducer switch
            {
                Reducer.AddItemToInventory args => Reducers.InvokeAddItemToInventory(eventContext, args),
                Reducer.ApplyDamageToPlayer args => Reducers.InvokeApplyDamageToPlayer(eventContext, args),
                Reducer.CreateInteractableObject args => Reducers.InvokeCreateInteractableObject(eventContext, args),
                Reducer.CreateProjectile args => Reducers.InvokeCreateProjectile(eventContext, args),
                Reducer.EnemyAttackPlayer args => Reducers.InvokeEnemyAttackPlayer(eventContext, args),
                Reducer.EnemyTransitionMap args => Reducers.InvokeEnemyTransitionMap(eventContext, args),
                Reducer.EquipItem args => Reducers.InvokeEquipItem(eventContext, args),
                Reducer.ExecuteAttack args => Reducers.InvokeExecuteAttack(eventContext, args),
                Reducer.ExecuteContextualAction args => Reducers.InvokeExecuteContextualAction(eventContext, args),
                Reducer.ForcePlayerPosition args => Reducers.InvokeForcePlayerPosition(eventContext, args),
                Reducer.GetMapData args => Reducers.InvokeGetMapData(eventContext, args),
                Reducer.GetPlayerInfo args => Reducers.InvokeGetPlayerInfo(eventContext, args),
                Reducer.GetPlayerPosition args => Reducers.InvokeGetPlayerPosition(eventContext, args),
                Reducer.GetProjectilesInMap args => Reducers.InvokeGetProjectilesInMap(eventContext, args),
                Reducer.GetResourceById args => Reducers.InvokeGetResourceById(eventContext, args),
                Reducer.GetResourceByKey args => Reducers.InvokeGetResourceByKey(eventContext, args),
                Reducer.GiveArrowsToPlayer args => Reducers.InvokeGiveArrowsToPlayer(eventContext, args),
                Reducer.HealPlayer args => Reducers.InvokeHealPlayer(eventContext, args),
                Reducer.HealthCheck args => Reducers.InvokeHealthCheck(eventContext, args),
                Reducer.InitMapTransitions args => Reducers.InvokeInitMapTransitions(eventContext, args),
                Reducer.ListResourcesByType args => Reducers.InvokeListResourcesByType(eventContext, args),
                Reducer.OnConnect args => Reducers.InvokeOnConnect(eventContext, args),
                Reducer.OnDisconnect args => Reducers.InvokeOnDisconnect(eventContext, args),
                Reducer.PickupItem args => Reducers.InvokePickupItem(eventContext, args),
                Reducer.ProcessHit args => Reducers.InvokeProcessHit(eventContext, args),
                Reducer.RegisterPlayer args => Reducers.InvokeRegisterPlayer(eventContext, args),
                Reducer.RegisterResource args => Reducers.InvokeRegisterResource(eventContext, args),
                Reducer.RemoveEnemy args => Reducers.InvokeRemoveEnemy(eventContext, args),
                Reducer.RemoveResource args => Reducers.InvokeRemoveResource(eventContext, args),
                Reducer.ReplaceAllTemplates args => Reducers.InvokeReplaceAllTemplates(eventContext, args),
                Reducer.RevivePlayer args => Reducers.InvokeRevivePlayer(eventContext, args),
                Reducer.SetPlayerMaxHealth args => Reducers.InvokeSetPlayerMaxHealth(eventContext, args),
                Reducer.SpawnEnemy args => Reducers.InvokeSpawnEnemy(eventContext, args),
                Reducer.SpawnPlayerAtMap args => Reducers.InvokeSpawnPlayerAtMap(eventContext, args),
                Reducer.SpawnTestEnemy args => Reducers.InvokeSpawnTestEnemy(eventContext, args),
                Reducer.SyncResourceRegistry args => Reducers.InvokeSyncResourceRegistry(eventContext, args),
                Reducer.TestMessage args => Reducers.InvokeTestMessage(eventContext, args),
                Reducer.UnequipItem args => Reducers.InvokeUnequipItem(eventContext, args),
                Reducer.UpdateEnemyAi args => Reducers.InvokeUpdateEnemyAi(eventContext, args),
                Reducer.UpdatePlayerPosition args => Reducers.InvokeUpdatePlayerPosition(eventContext, args),
                Reducer.UpdateProjectiles args => Reducers.InvokeUpdateProjectiles(eventContext, args),
                Reducer.UpdateResource args => Reducers.InvokeUpdateResource(eventContext, args),
                Reducer.UseHealthConsumable args => Reducers.InvokeUseHealthConsumable(eventContext, args),
                _ => throw new ArgumentOutOfRangeException("Reducer", $"Unknown reducer {reducer}")
            };
        }

        public SubscriptionBuilder SubscriptionBuilder() => new(this);
        public event Action<ReducerEventContext, Exception> OnUnhandledReducerError
        {
            add => Reducers.InternalOnUnhandledReducerError += value;
            remove => Reducers.InternalOnUnhandledReducerError -= value;
        }
    }
}
